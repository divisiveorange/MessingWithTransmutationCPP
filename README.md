# Prelude:

2 principles I've liked about Object-Oriented Programming is that an object's state should be hidden via delegating the management of its state to the object itself, and that one should put as much of the state of an object into it's class.

An example of the former is that, in the case of a linked list, instead of every linked list element having a pointer to the next element or null, one can have a LinkedListElement class/interface which classes called "LastLinkedListElement" and "NotLastLinkedListElement" can derive from/implement such that NotLastLinkedListElement contains a pointer/reference to another LinkedListElement and LastLinkedListElement has no data member for that. 

When implementing this in most languages including C++, when adding a new element to the end, one would have to replace the current LastLinkedListElement object with a new NotLastLinkedListElement object and would then have to modify the second last element to point to this new object because you (usually) can't change the type of an object after construction.

Technically speaking, this is not violating the first principle because the state of the object holding the last item is not being managed from outside itself, because it is being destroyed and replaced by another object. But if we think about the abstract idea of THE LinkedListElement that holds a specific piece of data, that LinkedListElement is having its state managed by the second last element.

In this example, it's relatively easy to change every pointer to this specific object to point to the new object, but in a more complex object graph, this would be quite a non-trivial problem. This is easier in idiomatic Rust code (without Rc<RefCell> everywhere) by it only allowing a single mutable reference. It "solves" this by not allowing this complex object graph. 

What would combine these principles is if the LastLinkedListElement could transmute itself inplace to be a NotLastLinkedListElement. 

# The specific systems that I would like to use transmutation with:

A controversial opinion I have is that I like multiple inheritance. I don't think I would be willing to go so far against the grain as to say it's good, but I do like it. An example for where I want to use multiple inheritance (as seen in the Forest folder of the code) is for a set of trees. 

Say we want each node in the trees to be able to point to the node above and the nodes below, if we follow the idea of encoding this in the type system, instead of using something like null, we should have some types that have pointers down and or have a pointer up the graph. The top of a tree would have no up pointer, the bottom would have no down pointers (and let's just say only the bottom elements hold data, kinda like in union find) and the other nodes would have both an up pointer and down pointers. An issue with creating just 3 classes like that is that a tree can potentially only consist of a single node and so being both a bottom and a top.

Additionally, what type should the up and down pointers be? They could just of type Node, but we know that if an object has an up pointer pointing to it, it can't be the bottom and vise versa. Therefore, we can create 4 classes, Top (with no data), Bottom (with a Data field), NonTop (with an up pointer) and NonBottom (with down pointers) and then create concrete types by inheriting from 2 of those classes. By using inheritance and not interfaces, we can more easily reason about the structure of the object graph because there is more information being carried when we see an class pointer than an interface pointer as well as being able to share more code across the implementations.  

The 2 advantages of inheritance over interfaces is code sharing and a more rigid code structure . The downside is a more rigid code structure. A more rigid structure is not necessarily bad because if it was, we'd all be using languages with dynamic typing like javascript and python. 

(though the, in my opinion underrated, Skeletal Implementation Pattern, can rectify the code sharing limitations of interfaces... by using inheritance internally. Therefore, making inheritance vs interfaces merely more rigid vs less rigid).

But, in this set of trees, we might want to combine trees into a larger tree (union find) and that would mean that a Top node would have to be replaced by a NonTop, and so we of course need transmutation for this to be a clean operation. 

# Defining what I want and discussing alternatives: 

My ideal result would be to be able to hold any base class pointer (or an interface reference in Java but I'll stick to C++ terms from this point onwards) be able to call a method that could modify the underlying type to another type that derives from the base class, that all pointers to this object via base class pointers remain valid, that this transmutation operation is always valid and finally that this doesn't make an additional memory allocation.

But first, let's discuss some alternative systems (and how they can work in C++).

The obvious solution to allowing transmutation is to simply put a pointer to the object in a wrapper and have external objects point to this wrapper. This basic idea works in most languages and works safely. There is a question of how to actually access the internal data. The simplest solution is to have a function that returns the internal pointer. The safety and correctness of this depends on the language used: in Java, this would be incorrect because the caller would be holding an object no longer in the proper object graph, but it would be memory safe due to the garbage collector. In Rust, if not in a RefCell, the borrow checker should prevent this and if it was in a refcell, the program would crash, but remain memory safe. In C++, while it would be unsafe and incorrect to hold a pointer to the pre-transmutation object, the conventions of the language should accept being able to get an internal pointer, because there is precedence with unique\_ptr and shared\_ptr both having a .get function that returns a raw pointer. But from those smart pointers, we can learn better conventions for doing this: we can overload operator-> to forward through all the methods of the internal type. This syntax to use these methods would be the same as if the internal type was being accessed through a pointer, even though the wrapper can safely exist as a value type. This does not prevent users from being able to store the internal pointer because .operator->() returns that pointer. In Rust, we can do something similar by implementing the deref trait except this uses the same syntax a as a value type and can prevent users from storing the internal object. The safer and more correct option in C++ and Java is to manually create forwardings of every method such that one can interact with the inner type however they like with the exception of storing it. This is, however, verbose. 

The above system is fails to satisfy my requirements for an ideal system by not being accessed through any base pointer, and by making an additional memory allocation for the internal type. The second issue is resolvable in several ways which we will get to later. The first issue however makes this idea generally infeasible in a clean manner. We could could have the wrapper inherit from the base class and then ensure (through some means) that only base class pointers that are internally our wrapper are accessible from other code but this is not free from issues. If the base class contains data itself our wrapper would have to hold this data in addition to the internal object - unclean and there could be non-virtual functions that use this data. If we limit the base class we want to interact with to be a pure abstract class (like an interface in Java), we could have the wrapper inherit from this base class and implement all the required methods by passing them on to the internal object. This however still has problems with how this base class should have some functions to mutate it's type (if we want access the wrapper through a base pointer, we obviously need to do what we want through that base pointer) but those functions can only work if the underlying type is of the wrapper, violating the Liskov Substitution Principle. And we can be sure that not all objects of the base are wrappers since the wrapper contains/points to other objects that derive from base. 

There is another issue with this idea that comes up with any wrapper class, the issues with how aspects of transmutation should happen in the "derived class" while the transmutation can only take place in the wrapper. A meta point: this serves as a good example of the issues of inheritance within this piece of writing. The natural place to talk about this issue is as soon as it comes up, right now, effectively deriving from the current topic. But these points are relevant for other systems too. So instead, I will use composition. Consider this right now a forward declaration of the general problems of a wrapper. 

As is typically a good idea when investigating a concept for C++, it's good to look at what Rust is doing. Where C++'s default dynamic polymorphism puts the VTable pointer in the object itself, Rust's system of Dyn Traits puts the VTable with the pointer to the object. One can employ this strategy in C++ but with more verbosity: typically this is called type erasure. The main advantage is that the underlying type does not need to exist with dynamic polymorphism in mind and does not have a vtable when it is not necessary. However, this system does not work for what we are trying to achieve because it means type safe operations depend on the "fat pointers" to an object and so the type cannot feasibly be changed without changing data held with every pointer to it. 

An alternative to typical OOP ideas that was often used before OOP became more common place in things like games is a "Fat Struct"; a struct that contains all the of the data an object could need and uses flags to distinguish things about the entity. A more concrete example would be instead of an entity class which child classes derive from, one could have an entity class that contains all the fields of what would otherwise be child classes and how its used is governed by flags indicating which what "type" of entity it represents. 

This system would be very well suited to transmutation by simply changing the flags and any data that would need to also change. However, the limitation of this system (as I described) is that it is clunky through every implicit type having shared state with other implicit types and any calls to polymorphic functions requiring a switch statement on the current implicit type. 

There are a few ways to go from this system. One could use this as the basis for switching to a "data-oriented programming" paradime where instead of all the data existing in the object, the object could instead just be a key into arrays (or maps) where each array stores all of a field within the object for every object. I think a system like that is even less clean but it can have real performance improvements if we want to access a field in many objects right after each other. 

One way to improve the usability of this system, and this goes for that data-oriented approach too, is to replace the flags and switch statements (or at least supplement them) with virtual functions. 

Another way is to use a tagged union instead. Instead of a fat struct holding all possible data elements with a flag, we can store a union of subtypes with a flag as a tag. 

Rust uses this concept heavily with their enum system. An issue with their implementation is that without wacky macros, every call needs to be in a switch statement even if every type in the enum has a particular method. The standard C++ version of a tagged union now is std::variant. std::variant has a very useful feature, the ability to use std::visit with an auto type that allows for running code that works on any type being held, usually with calling methods on that type with the same signature but different implementation. 

This is actually quite a good option for dynamic polymorphism in general. Instead of writing an interface (pure abstract class) one can write a wrapper class around a std::variant which has a set of functions that are then directly passed through to the variant using std::visit with auto. Then the classes that will be in the std::variant can implicitly satisfy the requirements for methods in the variant wrapper and be added the variant types. No inheritance or vtables necessary. Other classes can interact with this polymorphically the variant wrapper. The advantages of this system is being able to be easily allocated on the stack or in place in another object to reduce pointer indirection and improve cache locality and of course to allow easy transmutation through the wrapper class. 

The performance of this system vs a conventional inheritance system but with comparable allocation locations is unclear.

This system is more an alternative to interfaces as seen in Java not full inheritance. Inheritance can be achieved by having the derived types inherit from a base class, using CRTP to avoid a vtable in addition to the std::visit jump table. 

This below is the point I mentioned about the general problems with wrappers for transmutation:

This system of course allows easy transmutation through the wrapper class but this often is not ideal. With transmutation being very type specific, if we follow object-oriented principles, this should be done in the subtype itself. One option to rectify this is to pass in a pointer from the wrapper to the inner object when needed, memory efficient but slightly less clean because I feel like the inner object should handle it fully internally, and the other option is for the inner object to always hold the wrapper pointer, making construction a bit messier. 

But something about storing a pointer to the storage of an item doesn't sit right with me because, in the case of a tagged union, it shouldn't actually need to store that pointer. I can't find out exactly, but it seems to be the case that at least in clang and gcc, the first item of a std::variant is the currently stored item. Therefore, so long as the this pointer points to the true start of the object (so not in a weird multiple inheritance situation where the function is not being run from the actual class), one can just reinterpret\_cast the this pointer to be one of the exact std::variant type. This was where I moved onto alternative systems because that seems quite cursed, even if via using friend classes, it could be safe.

# Onto my journey to fulfill my requirements:

So, given one can just run `new(this) Obect()` the main issue is making sure there's enough space allocated for the type to transmute into. The obvious idea is just adding padding to the back of the class so that there's enough space for other types. How much padding can be calculated manually for all the types, but that is far form ideal. What would be better would be for the program to calculate this (probably with something with templates where the programmer enters the classes they want the object to be able to transmute into) but there's a problem, to work out how much padding is required, one would have to know how much the current object takes up, which would include the padding. This is also a problem if you want to ensure there is enough space in Class A to transmute to Class B, which needs to have enough space to transmute to Class A, a problem. 

My next idea was to store items in a union, under the assumption that the address of a union and the item in the union is always the same. One can declare the union type a friend of the transmutable classes, and set the class constructors to be private so that they can only be constructed in the union type. The issue with this approach is that when I tried to put this union type in a vector, I realised a vector needs the type to have a move or copy constructor and a union does not have one. I argue that being able to store the value type in another object instead of directly on the heap is a necessity because you can do that with normal polymorphic types, must just access it through a reference or pointer to use it polymorphically. Sadly, copy and move constructors can't be virtual and so the best solution is to add virtual move() and clone() methods that the union type can call. 

An alternative to get copy and move constructors for free is to store the objects in std::variant. As mentioned prior, std::variant seems to store the internal object as the first field and so, one should just be able to reinterpret the std::variant pointer as a base class pointer. Transmutating from the internal object runs into the same issues as foregoing vtable based polymorphism in favour of a tagged union. Reinterpreting the this pointer as a std::variant remains somewhat cursed and so I moved on from this idea. 

Even if one can ensure this object can only be constructed by the union type, this still feels unsafe. I would rather the transmutation were to happen in a type that holds the space itself, ideally with a static assert. 

Regardless of those issues, I begun writing code using a union type. This is a non-fiction story, not a report.

# About the program I intend to use transmutation with (scroll up):

This is an implementation of union find (with some other stuff) and in this, data nodes are created at the bottom and then merged with other nodes which creates a new node above them. The caller should hold onto the bottom nodes. How should one handle ownership of these objects? 

Well, whatever controller class can own the bottom nodes in a collection of unique\_ptrs or something but what about the non-bottom nodes? A shared\_ptr held by the 2 nodes below would work but shared\_ptrs are slow. Having 1 have a unique\_ptr and the other having a raw pointer is quite messy. It could be slightly improved with using new and delete and having a variable to be used in the destructor, but that's not great either. I think the best solution, is to just have the controller class own everything and use raw pointers in the tree. To store elements in an arena allocator, which is also more performant. I realise that this is how most things like this should be owned. 

So then I'll build an arena allocator and I can also use transmutation there. 

I could allocate a fixed size with a single call to malloc or new[] or make\_unique\_for\_overwrite<T[]> (we really have a wealth of options) or mix an array and linked list for pointer stability and memory expandability. An linked array sounds like a great opportunity for a design that relies on transmutability. 

As mentioned at the top, one can create a base class for linked list element and then inherit from that to create a type which has a next ptr and one that doesn't. But in this situation, we can go further than just that, we create more structure to this object graph by requiring that there can only be one array that is not full by having all next pointers only point to a full array. And so, like with the union find tree, we can create these classes: an base Arena type and then derived from that we can have:
FullArena, IncreasableArena, ArenaAlone and ArenaWithNext
and then by picking 2 of these (where they are compatible) we can have these non-abstract classes:
FullAlone, FullWithNext, IncreasableAlone and IncreasableWithNext.

At this point with 9 classes, it's clear that this is actually a bad idea and one should just use a std::list<std::vector>> based class, but that's of course less fun. 

The transmutability that's required for this is for the objects to be able to gain a next pointer, and lose a next pointer if we add a stack based partial destructor. It actually makes more sense to move a pointer to the main data around instead of the linked array element when an array becomes full. 

For the underlying data, I decided to use malloc and free since they are the easiest to understand because the runtime implicitly keeping track of initialised items in a new[] array, without a programmer accessible field, doesn't sound great. Using malloc to allocate memory for the transmutable linked elements for consistency reveals a very simple way to do transmutation, just specify the size you need (probably by using sizeof(yourUnionType)). Unless one type needs more than 16 byte alignment (which I think would just be some wide SIMD implementations, and even then only really for performance), malloc provides sufficient alignment. It's not very safe, but C's allocation strategies prove themselves quite suited to transmutation for heap items. Since you still need to get the size from somewhere, this doesn't change that much, but it feels less un-idiomatic. 

This also helped me realise a pro and a con of non-smart-pointer ownership models. With a unique\_ptr, there must always only be 1 object that holds the unique\_ptr, which can be somewhat clunky with a complicated move operation. In contrast, raw pointers with new and delete allow more flexibility when switching ownership, so long as the final object graph has only 1 object responsible for deleting the resource and exceptions aren't thrown when moving. 

I then had an idea to allow some more safety and checks on the validity of transmuting: deriving from derived classes to create transmutable classes. 

Specifically, I created a class called PaddingForTrans and this takes in several template parameters, the first template parameter for the class you wish to make transmutable and the rest for the classes to transmute into, and then calculates the required padding and has that padding. One can then derive from the class they wish to transmute from and, privately, from this PaddingForTrans class to create a new class that can transmute, which I call "Trans[derived class name]". Then, in the base class, we can create an unimplemented virtual function to transmute for the Trans class to implement. Then, in the transmutation method we can run a templated check on the base class we want to access this object through, the current class and the class we wish to transmute to (which might be another Trans class despite not actually specifying that in the PaddingForTrans class we derived from) so we can use a static\_assert that there is enough space and alignment for the class we transmute to and a runtime assert that the location the Base pointer points to is the same with both types. 

The Trans class should actually use private or protected inheritance for the derived class and then have a function that returns the base class that can represent all the possible underlying types. Unlike the first wrapper example, callers are allowed, and encouraged, to store this pointer. This is of course so that one can't interact with this class in a way that might not work after transmutation. 

This does unfortunately mean that in the arena example, we have 13 classes, but we can be sure there is sufficient size and alignment to transmute because any underlying type needs to implement the transmutation function. 

And so I went an implemented by arena system and ran some basic tests and then moved onto implementing my union find system. Along the way discovering all the little requirements when mixing templates and inheritance and friend classes and how to best have every class in it's own file (I like that about Java but it's certainly easier in Java) (and I mean a single .h file per class because it's all templated, and compilation time doesn't bother me for this). 

However, this system has a problem, when interacting with a value type, you never go through the vtable because it should always be the one for the value type. This is a problem because if you put the Trans object in a container, the container will run the destructor, and run the destructor for the base classes, this is quite memory unsafe because it interacts with the data as if it was the type we first set, even though it isn't. Very bad.
The solution for this I decided to use is: a special container class! 

The issue came from the system interacting with the Trans type by it's declared type, so we need the code to forget the data's original type. We can do this by creating a new class for each Trans type that can be declared as a friend and so be able to call a private constructor for the Trans type and then store it in an aligned char[] and returns a pointer to the base class. 17 classes!

This is getting too much. 

While my code retains the Trans types, which means one can run s static\_assert for the required size, given a holder type is still required, I now believe it is better just put the objects in the holder type and rely on that being the only class allowed to call the inner object's constructor. 

But there's a bigger problem yet to come. 

I kinda glossed over checking that the base class pointer points to the same memory with 2 types. It's actually really important and it would be bad if you commented out that check to because it was creating issues with compiling (due to messy template stuff, it's not a static\_assert) because you could run into issues where you update a field in an object, have a passing assert that the value was changed, but in your debugger, it says nothing changed and when you go to a new function, your code uses the unchanged value. That would, hypothetically, be quite bad. Single inheritance works as you would expect with the this pointer always pointing the same value no matter the class because there should exist only a single vtable. In multiple inheritance however, the base class objects live next to each other in memory and casting to a base class pointer changes the pointer address to point to that base class object. This is also the case for data-less abstract classes because they add a new vtable ptr. As a result, for transmutations to work, any base class objects within the actual object need to be exist with the same amount of data between them to be able to transmute while accessing through that base class pointer. This, makes using multiple inheritance for this quite bad. It so happens that how I made my arena array happens to work, but I had to swap the order of inheritance around for my union find implementation (and I'm referring to objects through both classes they inherit from so putting the base class I wish to interact with the object through first doesn't resolve this). But this really goes against the spirit of this. And if one needs to manually count the space and positioning of each base object, one might as well just manually add padding to their classes. I don't think this is why most people with opinions on multiple inheritance don't like it because most people use it normally, but this is a reason against for me. Single inheritance works at least, but this is single inheritance in C++ so no inheriting from a pure abstract class like in Java with Interfaces. 

In theory, I could imagine a multiple inheritance system that works more like Java's interfaces to work with this. Where instead of directly accessing a vtable, code that uses an interface looks at the objects type and works out the method to call that way. I could imagine a way to get that to work with data members in a similar way to default methods, but that would be doing a lot at runtime which Java can get away with due to it's JIT compiler but I'm not sure C++ could. 


# Conclusion:
My general recommendation is to avoid this kind of vtable based transmutation. But if you really want to use it, single inheritance does work. And the best system to achieve that is to make each class a friend class holder for it that takes in template parameters for the classes to transmute into so there is space and alignment. While multiple inheritance can work, it's too dependent on the specific makeup of the types that I strongly recommend against it. 

What I do recommend instead is forgoing inheritance based dynamic polymorphism (but you can still use CRTP based code sharing inheritance within the inner types in a Skeletal Implementation Pattern) entirely in favour of storing types in an std::variant and using std::visit with an auto type, and passing through the pointer to that variant when calling functions that can transmute. This is actually valid (well maybe transmute it from the variant instead of a method from an object getting transmuted). Although while the types can effectively implement multiple "interfaces", I can't think of a good way to have different "interfaces" point to the same object (with assumptions around when transmutation can occur). 
