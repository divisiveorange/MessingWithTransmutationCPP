Prelude:

2 principles I've liked about Object-Oriented Programming is that an object's state should be hidden via delegating the management of its state to the object itself, and that one should put as much of the state of an object into it's class.

An example of the former is that, in the case of a linked list, instead of every linked list element having a pointer to the next element or null, one can have a LinkedListElement class/interface which classes called "LastLinkedListElement" and "NotLastLinkedListElement" can derive from/implement such that NotLastLinkedListElement contains a pointer/reference to another LinkedListElement and LastLinkedListElement has no data member for that. 

When implementing this in most languages including C++, when adding a new element to the end, one would have to replace the current LastLinkedListElement object with a new NotLastLinkedListElement object and would then have to modify the second last element to point to this new object because you (usually) can't change the type of an object after construction.

Technically speaking, this is not violating the first principle because the state of the object holding the last item is not being managed from outside itself, because it is being destroyed and replaced by another object. But if we think about the abstract idea of THE LinkedListElement that holds a specific piece of data, that LinkedListElement is having its state managed by the second last element.

In this example, it's relatively easy to change every pointer to this specific object to point to the new object, but in a more complex object graph, this would be quite a non-trivial problem. This is easier in idomatic Rust code (without Rc<RefCell> everywhere) by it only allowing a single mutable reference. It "solves" this by not allowing this complex object graph. 

What would combine these principles is if the LastLinkedListElement could transmute itself inplace to be a NotLastLinkedListElement. 

Defining what I want and discussing alternatives: 

My ideal result would be to be able to hold any base class pointer (or an interface reference in Java but I'll stick to C++ terms from this point onwards) be able to call a method that could modify the underlying type to another type that derives from the base class, that all pointers to this object via base class pointers remain valid, that this transmutation operation is always valid and finally that this doesn't make an additional memory allocation.

But first, let's discuss some alternative systems (and how they can work in C++).

The obvious solution to allowing transmutation is to simply put a pointer to the object in a wrapper and have external objects point to this wrapper. This basic idea works in most languages and works safely. There is a question of how to actually access the internal data. The simplest solution is to have a function that returns the internal pointer. The safety and correctness of this depends on the language used: in Java, this would be incorrect because the caller would be holding an object no longer in the proper object graph, but it would be memory safe due to the garbage collector. In Rust, if not in a RefCell, the borrow checker should prevent this and if it was in a refcell, the caller shouldn't be able to access the object. In C++, while it would be unsafe and incorrect to hold a pointer to the pretransmuation object, the conventions of the language should accept being able to get an internal pointer, because there is presidence with unique\_ptr and shared\_ptr both having a .get function that returns a raw pointer. But from those smart pointers, we can learn better conventions for doing this: we can overload operator-> to forward through all the methods of the internal type. This syntax to use these methods would be the same as if the internal type was being accessed through a pointer, even though the wrapper can safely exist as a value type. This does not prevent users from being able to store the internal pointer because .operator->() returns that pointer. In Rust, we can do something similar by implementing the deref trait except this uses the same syntax a as a value type and can prevent users from storing the internal object. The safer and more correct option in C++ and Java is to manually create forwardings of every method such that one can interact with the inner type however they like with the exception of storing it. This is, however, verbose. 

The above system is fails to satisfy my requirements for an ideal system by not being accessed through any base pointer, and by making an additional memory allocation for the internal type. The second issue is resolvable in several ways which we will get to later. The first issue however makes this idea generally infeasible in a clean manner. We could could have the wrapper inherit from the base class and then ensure (through some means) that only base class pointers that are internally our wrapper are accessible from other code but this is not free from issues. If the base class contains data itself our wrapper would have to hold this data in addition to the internal object - unclean and there could be non-virtual functions that use this data. If we limit the base class we want to interact with to be a pure abstract class (like an interface in Java except without being able to store public variables), we could have the wrapper inherit from this base class and implement all the required methods by passing them on to the internal object. This however still has problems with how this base class should have some functions to mutate it's type (if we want access the wrapper through a base pointer, we obviously need to do what we want through that base pointer) but those functions can only work if the underlying type is of the wrapper, violating the Liskov Substitution Principle. And we can be sure that not all objects of the base are wrappers since the wrapper contains/points to other objects that derive from base. 

As is typically a good idea when investigating a concept for C++, it's good to look at what Rust is doing. Where C++'s default dynamic polymorphism puts the VTable pointer in the object itself, Rust's system of Dyn Traits puts the VTABLE with the pointer to the object. One can employ this strategy in C++ but with more verbosity: typically this is called type erasure. The main advantage is that the underlying type does not need to exist with dynamic polymorphism in mind and does not have a vtable when it is not neccessary. However, this system does not work for what I am trying to achieve because it means type safe operations depend on the "fat pointers" to an object and so the type cannot feasibly be changed without changing data held with every pointer to it. 

An alternative to typical OOP ideas that was often used before OOP became more common place in things like games is a "Fat Struct"; a struct that contains all the of the data an object could need and uses flags to distinguish things about the entity. A more concrete example would be instead of an entity class which child classes derive from, one could have an entity class that contains all the fields of what would otherwise be child classes and how its used is governed by flags indicating which what "type" of entity it represents. 

This system would be very well suited to transmutation by simply changing the flags and any data that would need to also change. However, the limitation of this system (as I described) is that it is clunky through every implicit type havine shared state with other implicit types and any calls to polymorphic functions requiring a swtich statement on the current implicit type. 

There are a few ways to go from this system. One could use this as the basis for switching to a "data-oriented programming" paradime where instead of all the data existing in the object, the object could instead just be a key into arrays (or maps) where each array stores all of a field within the object for every object. I think a system like that is even less clean but it can have real performance improvements if we want to access a field in many objects right after each other. 

One way to improve the usability of this system, and this goes for that data-oriented approach too, is to replace the flags and switch statements (or at least supplement them) with virtual functions. 

Another way is to use a tagged union instead. Instead of a fat struct holding all possible data elements with a flag, we can store a union of subtypes with a flag as a tag. 

Rust uses this concept heavily with their enum system. An issue with their implementation is that without wacky macros, every call needs to be in a switch statement even if every type in the enum has a particular method. The standard C++ version of a tagged union now is std::variant. std::variant has a very useful feature, the ability to use std::visit with an auto type that allows for running code that works on any type being held, usually with calling methods on that type with the same signature but different implememtation. 

This is actually quite a good option for dynamic polymorphism in general. Instead of writing an interface (pure abstract class) one can write a wrapper class around a std::variant which has a set of functions that are then directly passed through to the variant using std::visit with auto. Then the classes that will be in the std::variant can implictly satisfy the requirements for methods in the variant wrapper and be added the variant types. No inheritence or vtables neccessary. Other classes can interact with this polymorphically the variant wrapper. The advantages of this system is being able to be easily allocated on the stack or in place in another object to reduce pointer indirection and improve cache locality and of course to allow easy transmutation through the wrapper class. 

The performance of this system vs a conventional inheritence system but with comparable allocation locations is unclear.

A general disadvantage of this system is that this is more an alternative to interfaces as seen in Java not full inheritence because code sharing difficult and clunky because this is literally composition not inheritence. Without the underlying classes holding a pointer to the wrapper, it's easy to achieve something like "public and not protected methods" where functions in the "base class" (variant wrapper) are callable by outside classes but not from the "child classes". But one can of course store a pointer to the wrapper within the subtypes, and if one wanted to change every private member of the wrapper class to be effectively protected, it could friend all the types in the variant. But, again, this feels clunky. 

This system of course allows easy transmutation through the wrapper class but this often is not ideal. With transmutation being very type specific, if we follow object-oriented principles, this should be done in the subtype itself. As mentioned above, one option is to include a pointer (and account for this when moving or copying) to the wrapper class, or at least a pointer to the variant. Of course when transmutating an object from the same object, one must not touch anything from the this pointer of the transmutating class after the transmutation is called. 

But something about storing a pointer to the storage of an item doesn't sit right with me because it shouldn't actually need to store that pointer. I can't find out exactly, but it seems to be the case that at least in clang and gcc, the first item of a std::variant is the currently stored item. Therefore, so long as the this pointer points to the true start of the object (so not in a weird multiple inheritance situation where the function is not being run from the actual class), one can just reinterpret\_cast the this pointer to be one of the exact std::variant type. This was where I moved onto alternative systems. 

